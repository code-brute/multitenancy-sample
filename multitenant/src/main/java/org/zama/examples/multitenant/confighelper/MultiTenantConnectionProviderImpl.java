package org.zama.examples.multitenant.confighelper;

import java.util.HashMap;
import java.util.Map;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.sql.DataSource;

import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.zama.examples.multitenant.model.master.Tenant;
import org.zama.examples.multitenant.model.master.TenantDataSource;
import org.zama.examples.multitenant.repository.master.TenantRepository;
import org.zama.examples.multitenant.util.Utils;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

/**
 * MultiTenantConnectionProviderImpl
 * 
 * @author Minly Wang
 * @since 2016年5月24日
 *
 */
@Component
@Transactional(value = "masterTransactionManager", readOnly = true)
public class MultiTenantConnectionProviderImpl extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl implements ApplicationListener<ContextRefreshedEvent> {
	private static final long serialVersionUID = 1L;

	private final static Logger LOGGER = LoggerFactory.getLogger(MultiTenantConnectionProviderImpl.class);

	private Map<String, DataSource> map;

	@Inject
	private TenantRepository tenantRepository;

	@Value("${spring.datasource.url}")
	private String url;

	@Value("${spring.datasource.dataSourceClassName}")
	private String dataSourceClassName;

	@Value("${spring.datasource.username}")
	private String user;

	@Value("${spring.datasource.password}")
	private String password;

	@Inject
	private DataSource dataSource; // injected here to get properties and to
									// provide default.

	@PostConstruct
	public void load() {
		map = new HashMap<>();
	}

	public void init() {
		for (Tenant tenant : tenantRepository.findAll()) {
			// in this experiment we are just using one instance of mysql. URL
			// is generated by r`eplacing master database
			// name with company key to get new database URL
			try {
				TenantDataSource dataSource = tenant.getTenantDataSource();
				String dbUrl = url.replace(Utils.databaseNameFromJdbcUrl(url), tenant.getTenantId());
				LOGGER.debug("Configuring datasource {} {} {}", dataSourceClassName, dbUrl, user);
				HikariConfig config = new HikariConfig();
				config.setDataSourceClassName(dataSourceClassName);
				config.addDataSourceProperty("url", dataSource.getUrl());
				config.addDataSourceProperty("user", user);
				config.addDataSourceProperty("password", password);
				HikariDataSource ds = new HikariDataSource(config);
				map.put(tenant.getTenantId(), ds);
				// initDbWithLiquibase(ds);
			} catch (Exception e) {
				LOGGER.error("Error in database URL {}", url, e);
			}
		}
	}

//	private void initDbWithLiquibase(HikariDataSource ds) throws SQLException, LiquibaseException {
//		Database database = DatabaseFactory.getInstance().findCorrectDatabaseImplementation(new JdbcConnection(ds.getConnection()));
//		Liquibase liquibase = new Liquibase("dbchangelog-product.xml", new ClassLoaderResourceAccessor(), database);
//		liquibase.update("test, production");
//	}

	@Override
	protected DataSource selectAnyDataSource() {
		LOGGER.debug("######### Selecting any data source");
		return dataSource;
	}

	@Override
	protected DataSource selectDataSource(String tenantIdentifier) {
		LOGGER.debug("+++++++++++ Selecting data source for {}", tenantIdentifier);
		return map.containsKey(tenantIdentifier) ? map.get(tenantIdentifier) : dataSource;
	}

	@Override
	public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
		// This is super critical to initialize after application is done with
		// configuring beans.
		init();
	}

	// TODO: add methods to add the datasources as companies are registered.

}
